## 数据库的发展史
单机版信息系统：基于文件进行存储

为了应对各式各样的查询需求，因为针对每一个查询需求，那是无穷尽的。

> 所有计算机的问题都可以通过增加一个中间层解决

通过增加一个中间层，把物理层（文件层）屏蔽掉，通过熟悉的术语进行查询。中间层要有逻辑的数据结构，比如表，列，类型。定义好之后，还需要写一个解析器，把这样的语句变成内部对文件的操作。这里需要编译原理的知识。

这样一来，自己的程序也可以调用逻辑层来编程，也不用直接操作文件了，简化了很多。

> SQL：最大的好处是用户完全不用考虑物理层那些文件的结构，只需要关注逻辑层的表就可以了

文件存储进行优化：不再采用简单的逗号分割，增加了索引、缓存、查询优化等手段。由于中间层的存在，所以这些变化对应用层没什么影响

### 并发访问
重要的功能增强：网络访问，从单机软件变成了客户端-服务器结构的软件。

基于文件的操作改成及宇航的操作：每个人的修改只能影响这一行。这样解决了文件并发访问，数据被覆盖丢失的情况。

但是如果同时修改同一行呢？那就还会有问题，解决办法——行加锁

### 原子性问题
就拿转账而言，这个操作必须是原子的，要么全部发生，要么根本不发生。这样类似的操作叫做`事务`

`Undo日志`实现事务管理
1. 在执行真正操作之前，要先记录数据项原来的值，把这样的日志写入日志文件中。如果事务执行到一半断电了，数据库冲抵就可以根据Undo日志文件进行恢复
2. Undo日志不记录数据项原来的值，还会记录事务的开始和结束。如果在日志文件中看到了提交事务或者回滚事务，则这个事务已经完成，不用再去恢复。如果只看到了开始事务，而看不到提交或者回滚，那么我就得恢复，恢复完成后，在日志文件中补上一行“回滚事务”，这样下一次就可以忽略这个事务
3. 如果日志还没写入就断电了呢？遵循两条简单的规则
  * 更新数据之前，一定要先把对应的日志写入硬盘的日志文件
  * “提交事务”这样的undo日志记录一定要在所有的新数据写入成功之后再写入

### 安全
定义三大类权限
* 对数据操作的，如SELECT、UPDATE、INSERT等
* 对结构操作的，如创建表、修改表
* 做管理的，如备份数据、创建用户等

## Socket
两台主机之间通过失败重传来实现可靠的传输。

三次握手，滑动窗口，累计确认，分组缓存，流量控制，友好分手

> TCP协议很复杂，不能要求每个程序员都去实现建立连接的三次握手、累计确认、分组缓存，这些应该属于操作系统内核的部分，没必要重复开发，对于应用程序来讲，操作系统需要抽象出一个概念，让上层应用去编程，这就是Socket

TCP是两个进程之间的通信，客户端上可以有很多进程同时访问多个服务器，服务器上也有多个进程对外提供服务，我们通过端口号将它们区分开。为什么不通过进程号呢？

进程号是一个动态的东西，如果服务器端的进程重启了，进程号就变了。服务端都是被动访问的，所以大家需要知道它提供的服务的端口号。这个端口号就像一扇门，服务端的进程就在这扇门后面监听，等待客户端的连接。

> TCP的连接必须通过客户端IP、客户端PORT，服务端IP和服务端PORT来确定

## CPU和内存
理解CPU和内存是怎么一起工作的，绝对是集中中的基础。

简化一下CPU和内存，内存就是一个个小格子。每个格子都有一个编号，这个编号称为内存的地址，格子中的数据可以被CPU读写。CPU结构超级复杂，我们先关注运算器和寄存器

运算器可以进行各种运算，但是有一个限制，即这个运算器不能直接操作内存进行运算，它在运算时使用的是内部的数据格子，学名寄存器。

CPU必须把数据装载寄存器中才能进行运算。CPU运行速度很快，但是能做的事情却十分简单，主要是以下4种
* 从内存中某个格子读取数据，放入自己内部的寄存器Rx
* 把Rx的数据写入内存的某个格子中（会覆盖原有的数据）
* 进行数学运算（加减乘除）和逻辑运算（AND/OR）
* 根据条件进行跳转

CPU在运行时从哪里获取指令呢？还是内存，指令也需要在内存中才能被CPU访问到，CPU读取指令后，会进行分析译码，再进行计算

> 内存小格子中存放的不仅仅是数据，还存放着至关重要的程序指令。我们需要告诉CPU第一条指令在什么地方，然后就可以疯狂运行了