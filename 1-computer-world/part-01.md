## 我是一个线程

线程优先级

执行时间片：每个线程只能在CPU上运行一段时间，到了时间就得让别人用了。

线程状态：等待，就绪，运行反复轮转

线程池

规则
1. 不知道什么时候会被挑中执行
2. 执行的过程中随时可能被打断，让出CPU
3. 一旦出现硬盘、数据库这样耗时的操作，也得让出CPU去等待
4. 数据来了，你也不一定能马上执行，还得等着CPU挑选

数据库连接池

基于原数据的数据修改，需要加锁操作，比如存款取款

死锁的情况：比如转账操作，需要对两个资源（账户）进行加锁，如果不幸别的线程也需要这两个资源，一旦各执一锁，就会出现死锁

如果避免死锁：构造一个方法，用来计算资源的大小，计算出来后，永远按照大到小的方式来获得锁。

> 所谓资源的大小，其实就是把这个资源变成一个数来比较，例如，可以用字符串的hashcode来比较

谨记：多个资源加锁要牢记，一定要按照Boss的算法比较大小，然后从最大的开始加锁

## TCP/IP

失败重传、拆分编号

不需要事先建立真正的连接通道，每个编号小块走的路也可能不一样，每个小块也可能不按次序（失序）到达。

> 中间节点并不承诺提供可靠的连接通道，物资完全可能失序、重复、甚至丢失，所谓可靠的传输完全由两个端点来实现

TCP连接：TCP连接是虚拟连接，连接的状态信息并不会在路上保存，连接的状态信息是在两端维持的。

三次握手：主要验证双方的收发能力没问题，就证明连接是通的，就可以正式发货了。假设B端与S端通信
1. 第一次握手，B端发送数据包，S端收到了，S端就会明白B端的发送能力和自己的接收能力没问题
2. 第二次握手，S端发送数据包，B端收到了，B端就会明白自己的发送和接受能力都没问题，S端的发送和接受能力也没问题，但是S端还不清楚自己的发送能力如何，所以需要第三次握手
3. 第三次握手，B端发送，S端收到了，这次的目的就是消除S端对自己的发送能力和B端的接收能力的担忧而已

在网络世界中，中间节点就是路由器

重发时间：确定一个时间，如果超过时间还没收到回应，默认数据包丢失，只能重发

问题：如果发送6，7，8号数据包，其中6号数据包未到达，7号和8号数据包到达了，则也不会回送7号和8号的到达信息数据包，而是暂存起来。如果都到达了，发送了6号，7号，8号的到达信息数据包，但是其中6号丢失了，发送端收到了8号数据包，则可以直接理解为6，7号均到了，只是确认到达数据包丢失了。树立这个机制的目的是什么？

滑动窗口协议：为了提高收发效率

## CPU
为数不多的寄存器能临时记一点东西，但是运行飞快。工作以纳秒为单位。相比而言，内存慢百倍 ，硬盘慢百万倍。我的工作
* 运行指令
* 不能保存指令，指令全在内存里
* 第一条指令放在地址0xFFFFFFF0处

中断向量表

CPU运行环境
* 寄存器
* 程序计数器，记住执行的下一条指令

系统总线 I/O总线

直接内存访问（Direct Memory Access，DMA），直接把数据装载到内存，装载完成后发送一个信号

程序的局部性原理：访问了一个内存位置以后，过不了多久还会再次访问，一个内存位置被访问了，附近的位置很快也会被访问到。

流水线：4只手同时工作
* 第一只手负责打电话向内存要指令
* 第二只手翻译指令
* 第三只手执行指令
* 第四只手把结果写回内存

## 我是一个进程
冯诺依曼，提出“存储程序”的思想，各种各样不同功能的代码写好以后，和程序使用的数据一起存放在计算机的存储器中，然后计算机按照存储的程序逐条取出指令加以分析，并执行指令所规定的操作。

计算机从逻辑上分为五大部件：运算器、控制器、存储器、输入设备、输出设备

木秀于林，风必摧之

不患寡而患不均

多道程序：在内存中多装载几个程序，如果某个程序需要读/写硬盘了，你就运行另一个程序

正在运行的程序叫做进程

进程控制块：由于涉及到多道程序，那么切换程序运行的时候，就需要操作系统保存好现场，比如这个程序运行到第xxx行指令，寄存器值等，这些信息统称为进程控制块PCB